uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

in vec3 vLightFront;

#ifdef DOUBLE_SIDED
  in vec3 vLightBack;
#endif

#rb_include common
#rb_include color_pars_fragment
#rb_include map_pars_fragment
#rb_include alphamap_pars_fragment
#rb_include lightmap_pars_fragment
#rb_include envmap_pars_fragment
#rb_include fog_pars_fragment
#rb_include shadowmap_pars_fragment
#rb_include specularmap_pars_fragment
#rb_include logdepthbuf_pars_fragment

void main() {

  vec3 outgoingLight = vec3( 0.0 );  // outgoing light does not have an alpha, the surface does
  vec4 diffuseColor = vec4( diffuse, opacity );

  #rb_include logdepthbuf_fragment
  #rb_include map_fragment
  #rb_include color_fragment
  #rb_include alphamap_fragment
  #rb_include alphatest_fragment
  #rb_include specularmap_fragment

  #ifdef DOUBLE_SIDED

    float isFront = float( gl_FrontFacing );
    fragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;

    if ( gl_FrontFacing )
      outgoingLight += diffuseColor.rgb * vLightFront + emissive;
    else
      outgoingLight += diffuseColor.rgb * vLightBack + emissive;

  #else

    outgoingLight += diffuseColor.rgb * vLightFront + emissive;

  #endif

  #rb_include lightmap_fragment
  #rb_include envmap_fragment
  #rb_include shadowmap_fragment

  #rb_include linear_to_gamma_fragment

  #rb_include fog_fragment

  // fragColor = vec4( outgoingLight, diffuseColor.a );  // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

  fragColor = vec4(outgoingLight, diffuseColor.a);
}
